--[[ Lua code. See documentation: https://api.tabletopsimulator.com/ --]]
--TableTop Simulator UNO Scripted
--Steam Workshop ID : 814121724
--Last UpdatedB By: ITzMeek
--Date Last Updated: 5-24-2020
--TTS Version Created On: v12.3.5

debugging = false

--[[GUID Static References]]
startingDeck_GUID = "18c2e8"
playMatt_GUID = "f82f1f"
rotationMatt_GUID = "7b482f"
playDeckZone_GUID = "600b0b"
drawDeckZone_GUID = "45f602"

--[[String Variables That Are Used For Different Messages In The UI]]--
Waiting_For_Game_Start_Message="Waiting For The Host (%s) To Start The Game"
Waiting_For_Stacking_Message="Waiting For %s To Stack A Card, Or Draw Cards"
Waiting_For_Wild_Card_Message="Waiting For %s To Pick A Color"
Waiting_For_Trade_Message="Waiting For %s To Trade Their Cards With Another Player"

--[[Table used to get quick references of the player colors in this game mode]]
PLAYERS_REF = {
    Player.Green,
    Player.Blue,
    Player.Purple,
    Player.Pink,
    Player.White,
    Player.Red,
    Player.Orange,
    Player.Yellow}
--[[Static reference of world locations in the world for where the player label token should be located for a given player]]
TOKENLOCATIONS_REF = {
    ["GREEN"]  = {   0,    1.5,    9},
    ["BLUE"]   = { 6.36,   1.5, 6.36},
    ["PURPLE"] = {   9,    1.5,    0},
    ["PINK"]   = { 6.36,   1.5,-6.36},
    ["WHITE"]  = {    0,   1.5,   -9},
    ["RED"]    = {-6.36,   1.5,-6.36},
    ["ORANGE"] = {   -9,   1.5,    0},
    ["YELLOW"] = {-6.36,   1.5, 6.36}}
--[[Static reference of rotations to keep the player label token facing outward for each given player]]
TOKENROTATIONS_REF = {
    ["GREEN"]  = {    0, 180,    0},
    ["BLUE"]   = {    0, 225,    0},
    ["PURPLE"] = {    0, 270,    0},
    ["PINK"]   = {    0, 315,    0},
    ["WHITE"]  = {    0, 360,    0},
    ["RED"]    = {    0,  45,    0},
    ["ORANGE"] = {    0,  90,    0},
    ["YELLOW"] = {    0, 135,    0}}
--[[Static table of attributes for spawning the draw buttons]]
DRAWBUTTONS_REF = {
    ["TOP"]      = { -2,  1.2,   2.3},
    ["BOTTOM"]   = { -2,  1.2,  -2.3},
    ["SCALE"]    = { 1.5, 1.5,   1.5},
    ["POSITION"] = { 0,   0.1,   0  },
    ["ROTATION"] = { 0,   0,     0  },
    ["WIDTH"]    = 1500,
    ["HEIGHT"]   = 700,
    ["FONTSIZE"] = 250}
YIELDSTATE = {
    ["STACK"] = "stacking",
    ["WILD"] = "wild",
    ["TRADE"] = "trade"}

FAKEPLAYERS ={

}

drawButtons = {}                --Array used for the two 'Draw Card' buttons next to the draw deck
tokenLocations = {}             --Array used to keep reference for the current player token locations during runtime
tokenRotations = {}             --Array used to keep reference for the current player token rotations during runtime
seatedPlayers = {}              --Array used to keep reference for seated players during runtime

drawDeckZone = nil              --Object reference for the Scripting Zone where the Draw Deck is located
playDeckZone = nil              --Object reference for the Scripting Zone where the Play Deck is located
drawDeckObject = nil            --Object reference for the Game Object of the Draw Deck
playDeckObject = nil            --Object reference for the Game Object of the Play Deck
playMattObject = nil            --Object reference for the Game Object of the Play Matt
rotationMattObject = nil        --Object reference for the Game Object of the Rotation Matt
currentPlayerTokenObject = nil  --Object reference for the Game Object of the Current Player token

startingCardNumber = 7          --Code reference for the number of starting cards each player gets
gameStart = false               --Code reference for if a round of uno is started or waiting to start
gameRoom_Admin = nil            --Code reference for the host player
playerOne_Index = nil           --Code reference for the array index of the player that is 'player one'
currentPlayer = nil             --Code reference for the current player
currentPlayer_Index = nil       --Code reference for the array index of the current player
currentPlayer_Label = nil       --Code reference for the Steam name of the current player
nextPlayer = nil                --Code reference for the next player
nextPlayer_Index = nil          --Code reference for the array index of the next player
lastCard_Name = nil             --Code reference for the Name of the last played card
lastCard_Desc = nil             --Code reference for the Description of the last played card
clockwisePlay = true            --Code reference for the direction of turn order
stackingCounter = 0             --Code reference for how many cards will be drawn when stacking stops
playerIsStacking = false        --Code reference for if the current player is stacking or not
cardDrawn = false               --Code reference for if a player has drawn a card this turn
passButtonShown = false         --Code reference for if the 'Pass Turn' button is shown or not
winCondition = false            --Code reference for when a player meets the win condition
turnSkipping = false            --Code reference for when the next player is being skipped
decksFlipped = false            --Code reference for if the decks have been flipped when moving the play deck into the draw deck
gameloopCoroutine = nil         --Code reference for the our 'GameLoop' coroutine
yieldState = nil                --Code reference for the yield state of our 'GameLoop' coroutine

uno_Called = false              --Code reference for if a player has clicked the button and called UNO
uno_Button_Visible = false      --Code reference for if the Call UNO button is visible
color_Has_Uno = nil             --Code reference for what player is currently calling UNO
colorsWithUNO = {}              --Code reference for all players that currently have UNO

UI_DrawOneCard = true           --UI Toggle enable / disable only drawing one card
UI_AllowTurnPassing = true      --UI toggle to enable / disable passing your turn with out playing a card
UI_ShowMainMenu = false         --UI toggle to show or hide the main menu
UI_EnableStacking = false       --UI toggle to enable / disable 'all stacking' rules
UI_EnableD2Stacking = false     --UI toggle to enable / disable 'only stack +2' rules
UI_EnableD4Stacking = false     --UI Toggle to enable / disable 'only stack +4' rules
UI_EnableSevenZero = false      --UI toggle to enable / disable 7-0 rules
UI_EnableCallingUno = true      --UI toggle to enable / disable calling uno


---------------------------------------------------------------------------------------------------------------------------
--EVENT FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

--[[ The onLoad event is called after the game save finishes loading. --]]
function onLoad()
    --Set references to the static objects in our game
    drawDeckZone = getObjectFromGUID(drawDeckZone_GUID)
    playDeckZone = getObjectFromGUID(playDeckZone_GUID)
    drawDeckObject = getObjectFromGUID(startingDeck_GUID)
    playMattObject = getObjectFromGUID(playMatt_GUID)
    rotationMattObject = getObjectFromGUID(rotationMatt_GUID)
    --Reset the color tint to the PlayMat and Rotation Mat, just to be safe
    playMattObject.setColorTint({1,1,1})
    rotationMattObject.setColorTint({1,1,1})
    rotationMattObject.setRotation({0,0,180})
    --Disable interaction with Key objects to avoid players messing things up
    if(debugging == false)
    then
      drawDeckObject.interactable = false
      playMattObject.interactable = false
      rotationMattObject.interactable = false
      rotationMattObject.setLock(true)
      

    end
    --Update our reference table to the players that are seated
    UpdatePlayerTable()
    --Reset any key variables, just to be safe
    playerIsStacking = false

    --Init certain UI elements
    --Because we manipulate the "visibilty" tag on these elements later, we need to keep them active, but hide them
    UI.hide("StackingCardPanel")
    UI.hide("WildCardPanel")
    UI.hide("PassButtonPanel")
    UI.hide("UNO_Button")
    UI.hide("UNO_Penalty_Button")
    --Init the Message Panel and Starting Player Button
    UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Game_Start_Message):format(gameRoom_Admin.steam_name))
    --We default the Player One button to the Game Admin just for simplicity
    UI.setAttribute("playerOneButton", "Text", gameRoom_Admin.steam_name)
    UI.setAttribute("playerOneButton", "Color", gameRoom_Admin.color)
    
end--Function onLoad END
function onPlayerChangedColor(player_color)
    if gameStart == true
    then
        if player_color ~= "Grey"
        then
            ClearHands(false)

            if player_color ~= "Black"
            then
                if #Player[player_color].getHandObjects() == 0
                then
                    DealCardsToColor(7, player_color)
                    
                end
            end
        end
    end
    UpdatePlayerTable()
end--Function onPlayerChangedColor END
--[[This function is primarily used to make sure players are not throwing cards out of their hands]]
function onObjectDrop(player_color,dropped_object)

    local cardDropped = true
    --First, we only care if the object a player is dropping is a card
    if dropped_object.tag == 'Card'
    then
        --We check the "Owner" of the dropped card, and compare it to the Player that dropped it
        if dropped_object.getVar("Owner").color == Player[player_color].color
        then
            --Using Wait.time() and an in-line function, we can execute the following code after a certain amount of time
            Wait.time(
            function ()
                --First we get a reference to if the card being dropped is being played
                local inPlay = dropped_object.getVar("CardInPlay")
                --We also get a reference to the player color for simplicity
                local _player = Player[player_color]

                --We check if the card being dropped is NOT being played
                if inPlay == false
                then
                    --What we do here is loop through all of the objects that are now in the players hands, to see if the card being dropped
                    --is being dropped into their hand, in which case no further action is needed
                    for i = 1 , #Player[player_color].getHandObjects(), 1
                    do--Loop through all the objects the player has picked up
                        if Player[player_color].getHandObjects()[i] == dropped_object
                        then
                            cardDropped = false
                        end
                    end
                    --At this point, if the card being dropped is NOT being played, and is NOT being dropped into their hand, we will assume
                    --The card is being dropped out in the open, and we should return the card to their hand
                    if cardDropped == true
                    then
                        dropped_object.setPosition({_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']})
                        dropped_object.setRotation({_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,_player.getPlayerHand()['rot_z']})
                        broadcastToColor("Please only leave your cards in the play zone", player_color, getColorValueFromPlayer(player_color))
                    end
                end
            end,--End In-Line Function
            0.2)--This function will execute 0.2 seconds after a card is dropped
        end
    end
end--Function onObjectDrop END
--[[This is mostly used to stop players from trying to play more than one card at a time]]
function onObjectPickUp(player_color, picked_up_object)
    --If the card being picked up does not belong to the player picking it up, or if the player is NOT the Game Master (Black seat) we need to force them to drop it
    if picked_up_object.getVar("Owner").color ~= Player[player_color].color and player_color ~= "Black" and debugging == false
    then
        picked_up_object.drop()
        broadcastToColor("Do Not Take Other Players Cards", player_color, getColorValueFromPlayer(player_color))
    end
end--Function onObjectPickUp END
--[[This handles the logic of when a player tries to put a card into play]]
function onObjectEnterScriptingZone(zone, enter_object)
    
    if enter_object.held_by_color ~= "Black"
    then--First we check if the object is being held by the Game Master, as we don't want to apply logic to their actions
        if winCondition == false
        then--Next we check if the game has already been won, as we no longer need to apply logic after that point
            if enter_object.getGUID() ~= currentPlayerTokenObject.getGUID()
            then--Next, we dismiss the player label token, as we don't ever care if it enters a cripting zone
                if zone.getGUID() == playDeckZone_GUID
                then--Next, we check that the zone is the PlayZone
                    if enter_object.tag == 'Card'
                    then--Next, we check if the object entering the play zone is a card
                        if enter_object.getGUID() ~= playmatt_GUID
                        then--Next, we check that the object entering the zone is NOT the playMatt
                            if enter_object.getVar("FakePlayerCard") == true
                            then
                                PlayCard(enter_object)
                            else
                                if enter_object.held_by_color ~= nil
                                then--Next, we check that the object being checked is held by a player
                                    if currentPlayer ~= nil
                                    then--We check to make sure that the game logic has determined the current player
                                        if enter_object.held_by_color == currentPlayer.color
                                        then--Next, we check that the player holding the object is the current player
                                            if #Player[enter_object.held_by_color].getHoldingObjects() == 1
                                            then--Next, we check that the player is only holding one object, to avoid cheating the game logic

                                            ---------------------------------------------------------------------------------------------------------------------------
                                            --At this point, We know that a card is being properly played, so we can handle some logic that applies to the card itself
                                            ---------------------------------------------------------------------------------------------------------------------------

                                                if gameloopCoroutine ~= nil
                                                then--First, Check if the gameloopCoroutine object is *not* empty (nil). The only time it should be empty is the very first turn of the game, so in that case we can skip a little bit of extra logic
                                                    if coroutine.status(gameloopCoroutine) == "suspended"
                                                    then--Here, we check if the 'gameloopCoroutine' is currently suspended, meaning the game logic is waiting on a form of input. This should only be the case if we are waiting for a player to respond to a wild or draw card
                                                        --To determine what time of input we are waiting on, we can check our yieldState variable
                                                        if yieldState == YIELDSTATE.STACK
                                                        then--Here we check our yieldstate for "stacking". If this is the case, we are waiting for a player to repsond to a stacking rule, and the only cards that are allowed to be played, are draw cards of the same type
                                                            if enter_object.getName() == lastCard_Name
                                                            then--So we check if the card being played is the same face-type as the last card played
                                                                CheckCard(enter_object)
                                                            else
                                                                RejectCard(enter_object,"You Must Play A Card That Stacks, Or Draw Cards")
                                                            end

                                                        elseif yieldState == YIELDSTATE.WILD
                                                        then--Here we check our yieldstate for "wild". If this is the case, no cards should be played, and the current Player needs to pick a color
                                                            RejectCard(enter_object, "You Must Pick A Wild Color")

                                                        elseif yieldState == YIELDSTATE.TRADE
                                                        then
                                                            RejectCard(enter_object, "You Must Decide Who To Trade Cards With")
                                                        end
                                                    else--If our 'gameloopCoroutine' is *not* suspended, then there shouldn't be any special cards in play, and no special game logic is needed
                                                        CheckCard(enter_object)
                                                    end
                                                else--If our 'gameLoopCoroutine' is empty(nil), we can assume that this is the first turn of play
                                                    CheckCard(enter_object)
                                                end
                                            else--If the player is holding more than 1 card. This is a bit of legacy code, as technically there are other parts of the script that should make this impossible, but there's no harm in keeping it here
                                                RejectCard(enter_object, "You May Only Play One Card At A Time")
                                            end
                                        else--The player holding the object is not the Current Player
                                            RejectCard(enter_object,"It Is Not Your Turn Now")
                                        end
                                    end
                                end
                            end--End Fake Player Check
                        end
                    else--The object entering our PlayZone is NOT a card, but there are still some special cases we need to check for
                        if enter_object.tag ~= "Deck"
                        then
                            if enter_object ~= currentPlayerTokenObject
                            then
                                --The Deck and the Player Token will sometimes trigger out Play Zone, but we don't want to apply any logic to them. Anything else should not be allowed to enter the zone though
                                RejectObject(enter_object)
                            end
                        end
                    end
                end
            end
        end
    end
end--Funciton onObjectEnterScriptingZone END

---------------------------------------------------------------------------------------------------------------------------
--GAME LOGIC FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

--[[This function handles anything that needs taken care of at the start of a round of UNO]]
function InitGame()

    
    currentPlayer = seatedPlayers[playerOne_Index]
    currentPlayer_Index = playerOne_Index
    --Hide the UI elements that are only used at the start of a game
    UI.setAttribute("MainMenuContainer", "active", "False")
    UI.setAttribute("MessagePanel", "active", "False")
    --UI.setAttribute("HideMenuButton", "active", "False")
    
    
    --Tell the players what order they are in
    ListPlayers()
    UpdatePlayerLabel()
    

    --Create Objects & Buttons for drawing from the deck
    drawButtons[0] = spawnObject({
        type              = "PiecePack_Suns",
        position          = DRAWBUTTONS_REF.BOTTOM,
        rotation          = {0,180,0},
        scale             = {0.5,0.5,0.5},
        callback_fucntion = "dummyFunction",
        sound             = false})
    drawButtons[0].createButton({
        click_function = "DrawCard",
        function_owner = Global,
        label          = "Draw Card",
        position       = DRAWBUTTONS_REF.POSITION,
        rotation       = DRAWBUTTONS_REF.ROTATION,
        scale          = DRAWBUTTONS_REF.SCALE,
        width          = DRAWBUTTONS_REF.WIDTH,
        height         = DRAWBUTTONS_REF.HEIGHT,
        font_size      = DRAWBUTTONS_REF.FONTSIZE,
        color          = color(1, 1, 1, 1),
        font_color     = color(0, 0, 0, 1),
        tooltip        = "Draw a card from the Draw Deck"})
    drawButtons[1] = spawnObject({
        type              = "PiecePack_Suns",
        position          = DRAWBUTTONS_REF.TOP,
        rotation          = {0,0,0},
        scale             = {0.5,0.5,0.5},
        callback_fucntion = "dummyFunction",
        sound             = false})
    drawButtons[1].createButton({
        click_function = "DrawCard",
        function_owner = Global,
        label          = "Draw Card",
        position       = DRAWBUTTONS_REF.POSITION,
        rotation       = DRAWBUTTONS_REF.ROTATION,
        scale          = DRAWBUTTONS_REF.SCALE,
        width          = DRAWBUTTONS_REF.WIDTH,
        height         = DRAWBUTTONS_REF.HEIGHT,
        font_size      = DRAWBUTTONS_REF.FONTSIZE,
        color          = color(1, 1, 1, 1),
        font_color     = color(0, 0, 0, 1),
        tooltip        = "Draw a card from the Draw Deck"})

    drawButtons[0].setLock(true)
    drawButtons[1].setLock(true)
    --Shuffle the deck
    drawDeckObject.shuffle()

    --Seed the first card
    drawDeckCards = drawDeckObject.getObjects()
    local counter = 0

    --We iterate through the draw pile until we find a card that is NOT a wild, to use as our starting play card
    repeat
        counter = counter + 1
    until drawDeckCards[counter].description ~= "WILD"

    playDeckObject = drawDeckObject.takeObject({
        position = { playDeckZone.getPosition()['x'] , 1.5 , playDeckZone.getPosition()['z'] },
        rotation = { 0,180,0},
        index = counter-1,
        smooth =  false })

    lastCard_Name = playDeckObject.getName()
    lastCard_Desc = playDeckObject.getDescription()
    playMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    rotationMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    rotationMattObject.setRotation({0,0,180})
    --Deal 7 cards to each seated player
    for i,player in ipairs(seatedPlayers)
    do
        DealCardsToColor(startingCardNumber, player.color)
    end

    Wait.time(
        function () UpdateDeckObjects() end,
        0.5)


    --tell the game logic that the game has started
    gameStart = true
end--Function InitGame END
--This function gives me nightmares
function Reset_Game()

    --First we hide and reset any UI elements that are used during gameplay
    UI.hide("StackingCardPanel")
    UI.hide("WildCardPanel")
    UI.hide("PassButtonPanel")
    UI.hide("UNO_Button")
    UI.setAttribute("PlayerLabel", "active", "false")
    UI.setAttribute("playerOneButton", "Text", currentPlayer.steam_name)
    UI.setAttribute("playerOneButton", "Color", currentPlayer.color)

    UpdatePlayerTable()--Update our reference to the seated players
    ToggleDrawButtons(false)--Hide our draw card buttons
    Wait.time(
      function()
        ClearHands(true)--clear out the cards out of players' hands, ignoring if a player is seated there
      end,
    1)

    --Reset our UNO tracking variables
    uno_Called = false
    uno_Button_Visible = false
    color_Has_Uno = nil

    --This function will reset the play and draw decks after 2 seconds
    Wait.time(
        function ()
            UpdateDeckObjects()
            playDeckObject.interactable = true
            playDeckObject.setRotation({180,180,0})
            playDeckObject.setPosition({drawDeckZone.getPosition()['x'] , 3 , drawDeckZone.getPosition()['z']})
            --playDeckObject = nil
            Wait.time(function () drawDeckObject.shuffle() end, 1)
            end,
        2)
    --This function will reset any key variables after 3 seconds
    Wait.time(
        function ()
            gameStart = false
            winCondition = false
            playerOne_Index = currentPlayer_Index
            lastCard_Name = nil
            lastCard_Desc = nil
            gameloopCoroutine = nil
            playerIsStacking = false
        end,
        3)
    --This function will show the Show the Start Game UI elements after 4 seconds
    Wait.time(
        function ()
            UI.setAttribute("StartGameMenu", "active", "true")
            UI.setAttribute("MessagePanel", "active", "true")
            UI.setAttribute("MainMenuContainer", "active", "true")
            UI.show("MessagePanel")

            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Game_Start_Message):format(gameRoom_Admin.steam_name))
            UI.setAttribute("HideMenuButton", "visibility", "Host")
            UI.setAttribute("StartGameMenu", "visibility", "Host")
        end,
        4)
    --Reset the color tint of our Play Mat and Rotation Mat
    playMattObject.setColorTint({1,1,1})
    rotationMattObject.setColorTint({1,1,1})
    rotationMattObject.setRotation({0,0,180})



end--Function Reset_Game END
--[[This function is called after we've determined that a card is allowed to be put into play. This makes sure that the card played is a playable card]]
function CheckCard(currentCard)
    if lastCard_Name == nil
    then -- We check ifthe lastCard_Name is empty(nil), meaning this is the first card in the pile
        PlayCard(currentCard)
    else -- Otherwise, we need to check our current card against the last card
        if currentCard.getDescription() == "WILD"
        then -- First, we check if the currentCard is a wild card. This means we don't need to check against the lastCard
            PlayCard(currentCard)
        elseif currentCard.getName() == lastCard_Name
        then -- This checks if currentCard has the same face value as lastCard
            PlayCard(currentCard)
        elseif currentCard.getDescription() == lastCard_Desc
        then -- this checks if currentCard has the same colorvalue as lastCard
            PlayCard(currentCard)
        else --this means that currentCard is not a playable card
            RejectCard(currentCard,"This Card Cannot Be Played")
        end
    end
end--Function CheckCard END
--[[This function is used to return an invalid card to the players hand]]
function RejectCard(currentCard, game_message)

    --Grab a quick reference to the player that is holding the card
    local _player = Player[currentCard.held_by_color]
    if game_message ~= ""
    then--If the game_message is *not* empty, broacast it to the player
        broadcastToColor(game_message, _player.color ,getColorValueFromPlayer(_player.color))
    end
    --send the currentCard back to the player's hand
    currentCard.setPositionSmooth({_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']})

end--Function RejectCard END
--[[The function is mostly used to stop non-card objects from entering the game zones]]
function RejectObject(obj)


    if obj.held_by_color ~= nil
    then
        broadcastToColor("This object does not belong in the playing card area", obj.held_by_color, getColorValueFromPlayer(obj.held_by_color))
    else
        broadcastToAll("An invalid object entered the playing card area", getColorValueFromPlayer(PLAYERS_REF.WHITE))
    end

    local velocity = obj.getVelocity()
    obj.translate({
        ClampValue( -(math.floor(velocity.x*2)+5),-8,8),
        3,
        ClampValue( -(math.floor(velocity.z*2)+5),-8,8)})

end--Function RejectObject
--[[This function handles a little bit of logic when a card is being put into play, before we dive into our main Game Loop]]
function PlayCard(cardObj)

    if uno_Button_Visible == true
    then
        HideUNO()
    end

    cardObj.setRotationSmooth({0,180,0}, false, true)
    local FixedPos = playDeckZone.getPosition()
    cardObj.setPositionSmooth({FixedPos.x,3,FixedPos.z}, false, true)

    if #currentPlayer.getHandObjects() == 1
    then
        PlayerHasUNO(currentPlayer.color)
    end

    if #currentPlayer.getHandObjects() == 0 and winCondition == false
    then--If a player has no more cards in their hand after a card is played, a win condition has been met
        broadcastToAll(currentPlayer.steam_name .. " Has Played Their Last Card & Won The Round", getColorValueFromPlayer(currentPlayer.color))
        winCondition = true
        Reset_Game()
    end

    --we set the card's "CardInPlay" variable to true now that it has entered the play deck
    cardObj.setVar("CardInPlay", true)
    if winCondition == false
    then--If the Win Condition has not yet been met, we can continue with our game play logic
        if gameloopCoroutine ~= nil
        then--if our Game Loop is not empty, then we need to resume it. This should only be the case for a wild card, or draw card, and our game logic up to this point has made sure the correct conditions have been met, and we can safely resume our Game Loop
            if coroutine.status(gameloopCoroutine) == "suspended"
            then
                coroutine.resume(gameloopCoroutine)
            end
        end
        --Update our references to the last card that has been played
        lastCard_Name = cardObj.getName()
        lastCard_Desc = cardObj.getDescription()

        if lastCard_Desc ~= "WILD"
        then--So long as the last card played is NOT a wild card, we should update our play matts to the correct color
            playMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
            rotationMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
        end

        --Start our Game Loop
        gameloopCoroutine = coroutine.create(GameLoop)
        coroutine.resume(gameloopCoroutine)

    end

end--Function PlayCard END

--[[This function is called when a Player plays a card and only has one more card left in there hand]]
function PlayerHasUNO(color)

    if(UI_EnableCallingUno == true)
    then
        --We set the UNO button to a random position along the X access, to avoid other players from 'camping' the button location
        math.randomseed(os.time())
        UI.setAttribute("UNO_Button", "OffsetXY", ( math.random(-350,350).." 250") )

        --set the appropriate 'tracking' variables
        uno_Called = false
        uno_Button_Visible = true
        color_Has_Uno = color

        --We set the UNO button color to the player color with UNO to help identify
        UI.setAttribute("UNO_Button", "color", color )
        UI.show("UNO_Button")
    else
        colorsWithUNO[#colorsWithUNO+1] = color
        UI.setAttribute("UNO_Penalty_Button","visibility",getVisibilityTargerts(colorsWithUNO))
        UI.Show("UNO_Penalty_Button")
        uno_Button_Visible = true
    end

end--Function PlayerHasUNO END

--[[This function is called when someone presses the UNO button, or if play proceeds without someone calling the UNO button]]
function HideUNO()
    --Hide the UNO button so it can no longer be clicked
    UI.hide("UNO_Button")
    UI.hide("UNO_Penalty_Button")
    uno_Button_Visible = false
end--Function HideUNO END

--[[Helper Function that can be given a Player Color and a number, to deal that many cards to that Player]]
function DealCardsToColor(count,color)
    for i=1, count
    do
        local dealtCard
        local _player = Player[color]
        --drawDeckObject.deal(1, color)
        dealtCard = drawDeckObject.takeObject({
            position = {_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']},
            rotation = {_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,0},
            index = 1,
            smooth = false})

        dealtCard.setVar("Owner", _player)
        dealtCard.setVar("CardInPlay", false)
    end
end--Function DealCards END
--[[This function will clear out the cards a hand zone. Normally, this function will only clear hands that don't have a seated player, but can clear all hands if given a condition]]
function ClearHands(ignoreSeated)

    for i=1,#seatedPlayers
    do
        for j=1, #seatedPlayers[i].getHoldingObjects()
        do
            if seatedPlayers[i].getHoldingObjects()[j].tag=='Card'
            then
                seatedPlayers[i].getHoldingObjects()[j].setPositionSmooth(seatedPlayers[i].getHandTransform()['position'], false, true)
            end
        end
    end
    Wait.frames(
        function()
            for i, player in ipairs(PLAYERS_REF)
            do
                if player.seated == false or ignoreSeated == true
                then
                    if #player.getHandObjects() > 0
                    then
                        deckPosition = { drawDeckObject.getPosition()['x'] , drawDeckObject.getPosition()['y'] + 0.5 , drawDeckObject.getPosition()['z'] }
                        deckRotation = drawDeckObject.getRotation()
                        for i, card in ipairs(player.getHandObjects())
                        do
                            card.setRotation(deckRotation)
                            card.setPosition(deckPosition)
                        end
                        drawDeckObject.shuffle()
                    end
                end
            end
        end, 30)
end--Function ClearHands END
--[[This function will move players hands between one player, designated as a 'sender' and another player designated as a 'receiver'.
To simply swap hands between the sender and the receiver, set 'Recursive' to 0 when calling. Otherwise the function is designed to exchange hands with the player to your right]]
function ChangeHands(sendingPlayerIndex,receivingPlayerIndex,Recursive)
    
    --Create a reference to the Hand of the receiving player
    sendersHand = {}
    sendersHand = seatedPlayers[sendingPlayerIndex].getHandObjects()

    receiversHand = {}
    receiversHand = seatedPlayers[receivingPlayerIndex].getHandObjects()

    --Add any cards the players might actively be holding to the tables
    if isFakePlayer(seatedPlayers[receivingPlayerIndex].color) == false
    then
<<<<<<< Updated upstream
        if #seatedPlayers[receivingPlayerIndex].getHoldingObjects() ~= nil
        then
            for i=1,#seatedPlayers[receivingPlayerIndex].getHoldingObjects()
            do
                if seatedPlayers[receivingPlayerIndex].getHoldingObjects()[i].tag == 'Card'
                then
                    receiversHand[#receiversHand+i] = seatedPlayers[receivingPlayerIndex].getHoldingObjects()[i]
                end
=======
        for i=1,#seatedPlayers[receivingPlayerIndex].getHoldingObjects()
        do
            if seatedPlayers[receivingPlayerIndex].getHoldingObjects()[i].tag == 'Card'
            then
                receiversHand[#receiversHand+i] = seatedPlayers[receivingPlayerIndex].getHoldingObjects()[i]
>>>>>>> Stashed changes
            end
        end
    end
    if isFakePlayer(seatedPlayers[sendingPlayerIndex].color) == false
    then
<<<<<<< Updated upstream
        if #seatedPlayers[sendingPlayerIndex].getHoldingObjects() ~= nil
        then
            for i=1, #seatedPlayers[sendingPlayerIndex].getHoldingObjects()
            do
                if seatedPlayers[sendingPlayerIndex].getHoldingObjects()[i].tag == 'Card'
                then
                    sendingPlayerHand[#sendingPlayerHand+i] = seatedPlayers[sendingPlayerIndex].getHoldingObjects()[i]
                end
=======
        for i=1, #seatedPlayers[sendingPlayerIndex].getHoldingObjects()
        do
            if seatedPlayers[sendingPlayerIndex].getHoldingObjects()[i].tag == 'Card'
            then
                sendingPlayerHand[#sendingPlayerHand+i] = seatedPlayers[sendingPlayerIndex].getHoldingObjects()[i]
>>>>>>> Stashed changes
            end
        end
    end

    --Iterate through all of the objects (cards) in the sending players hands
    for j=1,#sendersHand
    do

        --First we set the owner of the card to be the receiving player
        sendersHand[j].setVar("Owner", seatedPlayers[receivingPlayerIndex])

        --Then we move the card to the receiving players hand, and fix its rotation
        sendersHand[j].setPosition( seatedPlayers[receivingPlayerIndex].getHandTransform()['position'] )
        sendersHand[j].setRotation({seatedPlayers[receivingPlayerIndex].getPlayerHand()['rot_x'],seatedPlayers[receivingPlayerIndex].getPlayerHand()['rot_y']+180,0})
    end

    --If Recursive is greater than 1, we will assume we are exchanging cards with the player to your right, instead of just swapping hands with 1 other player
    if Recursive > 1
    then
        --decrease Recusive by 1
        Recursive = Recursive-1
        --Call this function again, but with the receiving player now becoming the sender, and the next player in line being the new receiver
        ChangeHands(receivingPlayerIndex, getNextSeatedPlayerIndex(receivingPlayerIndex), Recursive )

    --If Recursive is equal to 0, we assume we only want to swap hands between the sender and the receiver
    elseif Recursive == 0
    then
        --Call this function again, but with the receiver being the new sender, the sender being the new receiver, and Recursive as -1 to bypass this check again
        ChangeHands(receivingPlayerIndex,sendingPlayerIndex,-1)
    end


    Wait.frames(
        function()
            for i=1,#seatedPlayers
            do
                for j=1,#seatedPlayers[i].getHandObjects()
                do
                    if seatedPlayers[i].getHandObjects()[j].getVar("Owner").color ~= seatedPlayers[i].color
                    then
                        _player =  Player[ seatedPlayers[i].getHandObjects()[j].getVar("Owner").color ]
                        seatedPlayers[i].getHandObjects()[j].setPosition( _player.getHandTransform()["position"] )
                        seatedPlayers[i].getHandObjects()[j].setRotation( {_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,0} )
                    end
                end
            end
        end, 20)

end--Function ChangeHands END

--[[This function is responsible for update both the Current Player token that moves around the board, and the Current Player UI element]]
function UpdatePlayerLabel(token)

    local tokenLocation
    local tokenLabel
    local tokenColor
    local tokenRotation

    if currentPlayer ~= nil
    then
<<<<<<< Updated upstream
        tokenLocation = getTokenLocation(currentPlayer.color)
=======
>>>>>>> Stashed changes
        tokenLabel = ("Current Player:\n%s"):format(currentPlayer.color)
        tokenColor = currentPlayer.color
        tokenRotation = getTokenRotation(currentPlayer.color)
        tokenLocation = getTokenLocation(currentPlayer.color)
    else
        tokenLabel = "No Player One"
        tokenColor = Player.Black.color
        tokenRotation = getTokenRotation(Player.Black.color)
        tokenLocation = getTokenLocation(Player.Black.color)
    end

    if currentPlayerTokenObject == nil
    then
        currentPlayerTokenObject = spawnObject({
        type              = "PiecePack_Suns",
        position          = tokenLocation,
        rotation          = {0,0,0},
        scale             = {0.8,0.8,0.8},
        callback_fucntion = "dummyFunction",
        sound             = false})
    end


    currentPlayerTokenObject.interactable = false
    currentPlayerTokenObject.use_gravity = false
    currentPlayerTokenObject.setColorTint(getColorValueFromPlayer(tokenColor))
    currentPlayerTokenObject.setPositionSmooth(tokenLocation,false,false)
    currentPlayerTokenObject.setRotation(tokenRotation)

    UI.setAttribute("PlayerLabel", "active", "True")
    UI.setAttribute("PlayerLabel", "text", tokenLabel)

    if currentPlayerTokenObject.UI.getXml() ~= ""
    then
        currentPlayerTokenObject.UI.setAttribute("PlayerLabel", "text", tokenLabel)
    else
        currentPlayerTokenObject.UI.setXmlTable(
        {
            {
                tag="HorizontalLayout",
                attributes=
                {
                    height=600,
                    width=1000,
                    position="0 0 -10",
                    color="rgba(0,0,0,0)",
                },
                children=
                {
                    {
                        tag="Text",
                        attributes=
                        {
                            id="PlayerLabel",
                            text= tokenLabel,
                            fontSize="130",
                            color= "white",
                            outline="black",
                            outlineSize="4 4"
                        },
                    },
                }
            }
        })
    end
end--Function UpdatePlayerLabel END
--[[This function broacasts what players are in what order, starting with player 1]]
function ListPlayers()

    --First we make sure to update our reference of seated players
    UpdatePlayerTable()

    local counter = 0

    for i = 1,#seatedPlayers,1
    do
        if currentPlayer~= nil
        then
            if seatedPlayers[(currentPlayer_Index + counter)].steam_name ~= nil
            then
                broadcastToAll(seatedPlayers[(currentPlayer_Index + counter)].steam_name .. " is player " .. i, getColorValueFromPlayer(seatedPlayers[(currentPlayer_Index+counter)].color))
            else
                broadcastToAll(seatedPlayers[(currentPlayer_Index + counter)].color .. " is a fake player " .. i, getColorValueFromPlayer(seatedPlayers[(currentPlayer_Index+counter)].color))
            end
            if (currentPlayer_Index + counter + 1) <= #seatedPlayers
            then
                counter = counter + 1
            else
                counter = (-currentPlayer_Index)+1
            end
        end
    end
end--Function ListPlayers END
--[[This function is called when one of the Draw Card buttons are clicked]]
function DrawCard(obj,color)

    if winCondition == false
    then
        if color ~= nil and color ~= "Black"
        then
            if color == currentPlayer.color
            then
                if yieldState == YIELDSTATE.STACK
                then
                    broadcastToColor("You Can Not Draw A Card At This Time",color, getColorValueFromPlayer(color))
                elseif yieldState == YIELDSTATE.WILD
                then
                    broadcastToColor("You Can Not Draw A Card At This Time", color, getColorValueFromPlayer(color))
                else
                    --Logic to show the "End Turn" button if that rule is enabled
                    if UI_AllowTurnPassing == true
                    then
                        if passButtonShown == false
                        then
                            UI.show("PassButtonPanel")
                            passButtonShown = true
                            UI.setAttribute("PassButtonPanel", "visibility", currentPlayer.color)
                        end
                    end
                    if UI_DrawOneCard == true and cardDrawn == true
                    then
                        broadcastToColor("You May Only Draw One Card per Turn. Play A Card, or Pass", currentPlayer.color,getColorValueFromPlayer(currentPlayer.color))
                        return
                    else
                        DealCardsToColor(1, color)
                        HideUNO()
                        UpdateDeckObjects()
                        cardDrawn = true
                    end
                end
            end
        end
    end
end--Function DrawCard END
--updates the reference to 'gameRoom_Admin' 'seatedPlayers' 'tokenLocations' & 'tokenRotations' based on the players seated at the table
function UpdatePlayerTable()
    local counter = 1

    --Empty our reference tables
    seatedPlayers = {}
    tokenLocations = {}
    tokenRotations = {}

    if Player.Black.seated
    then
        if Player.Black.admin
        then
        gameRoom_Admin = Player.Black
        end
    end

    for i, _player in ipairs(PLAYERS_REF)
    do--Go through our static PLAYERS_REF table

        if _player.admin
        then--Check if the player is the host or a promoted player
            gameRoom_Admin=_player
            if currentPlayer == nil
            then--For simplicity, if the currentPlayer is not set, we set it to the admin
            currentPlayer = _player
            currentPlayer_Index = counter
            playerOne_Index = counter
            end
        end
        if _player.seated
        then--If a given player is seated
            seatedPlayers[counter] = _player--add that player to our reference table, and update our tokenLocations table
            tokenLocations[counter] = getTokenLocation(i)
            counter = counter + 1
        else
            --Add any fake players to the game
            if isFakePlayer(_player.color)
            then
                seatedPlayers[counter] = _player
                tokenLocations[counter] = getTokenLocation(i)
                counter = counter + 1
            end
        end
    end

    if currentPlayer ~= nil
    then
        if #seatedPlayers > 0
        then
            if currentPlayer.seated == false
            then
                currentPlayer = seatedPlayers[#seatedPlayers]
                currentPlayer_Index = #seatedPlayers
            end
        end
    end

end--Function UpdatePlayerTable END
--This function keeps our references to the draw and play deck objects up to date, and will reset the play deck when the draw deck becomes too small
function UpdateDeckObjects()

    playZoneObjects = playDeckZone.getObjects()
    drawDeckCards = drawDeckObject.getObjects()


    if decksFlipped == true
    then
        --Shuffle Deck twice because why not?
        drawDeckObject.shuffle()
        drawDeckObject.shuffle()
        decksFlipped = false
    end

    for i, v in pairs(playZoneObjects)
    do
        if v.tag == "Deck"
        then
            playDeckObject = v
            playDeckObject.interactable = false
        end
    end

    --Re-Establish the deck objects interactable status]
    if drawDeckObject then
        if debugging == false then
            drawDeckObject.interactable = false
        end
    end
    if playDeckObject then
        if debugging == false then
            playDeckObject.interactable = false
        end
    end

    if #drawDeckCards < 18
    then
        playDeckObject.interactable = true
        playDeckObject.takeObject({
        position = { playDeckZone.getPosition()['x'] , 2.8 , playDeckZone.getPosition()['z'] },
        index = #playDeckObject.getObjects()-1,
        smooth = true })
        playDeckObject.flip()
        playDeckObject.setPositionSmooth({drawDeckObject.getPosition()['x'],drawDeckObject.getPosition()['y']+2,drawDeckObject.getPosition()['z']}, false, true)
        decksFlipped = true

        Wait.time(
            function () UpdateDeckObjects() end,
            1.0)
    end
end--Function UpdateDeckObjects END
--[[Calculates the next currentPlayer & currentPlayer_Index]]
function EndPlayerTurn()
    
    if clockwisePlay == true
    then
        if currentPlayer_Index + 1 > #seatedPlayers
        then
            currentPlayer_Index = 1
        else
            currentPlayer_Index = currentPlayer_Index + 1
        end
    else
        if currentPlayer_Index - 1 <= 0
        then
            currentPlayer_Index = #seatedPlayers
        else
            currentPlayer_Index = currentPlayer_Index - 1
        end
    end

    if clockwisePlay == true
    then
        if currentPlayer_Index + 1 > #seatedPlayers
        then
            nextPlayer_Index = 1
        else
            nextPlayer_Index = currentPlayer_Index + 1
        end
    else
        if currentPlayer_Index - 1 <= 0
        then
            nextPlayer_Index = #seatedPlayers
        else
            nextPlayer_Index = currentPlayer_Index - 1
        end
    end

    currentPlayer = seatedPlayers[currentPlayer_Index]
    nextPlayer = seatedPlayers[nextPlayer_Index]
    cardDrawn = false

<<<<<<< Updated upstream

    UpdatePlayerLabel()

=======
    
>>>>>>> Stashed changes
    UI.hide("PassButtonPanel")
    passButtonShown = false
    
    Wait.frames(
        function ()
            UpdatePlayerLabel()
        end,
        5
    )

    Wait.time(
        function ()
            UpdateDeckObjects()
        end,
        0.75)

    if isFakePlayer(currentPlayer.color) and turnSkipping == false
    then
        Wait.time(
            function()
                doFakePlayerTurn(currentPlayer.color,false)
            end,
        1)
    end

    turnSkipping = false
end--Function EndPlayerTurn END
--[[This is the function that does most of the logic for special cards]]
function GameLoop()
    if isFakePlayer(currentPlayer.color)
    then

        if lastCard_Name == "reverse"
        then--Check if the card played was a reverse.

            clockwisePlay = not clockwisePlay
            rotationMattObject.setLock(false)

            if clockwisePlay == false then
                rotationMattObject.setRotation({0,0,0})
            end

            if clockwisePlay == true then
                rotationMattObject.setRotation({0,0,180})
            end

            if #seatedPlayers == 2
            then
                turnSkipping = true
                EndPlayerTurn()
            end
            rotationMattObject.setLock(true)
            EndPlayerTurn()

        elseif lastCard_Name == "skip"
        then--Check if the card played was a skip
            turnSkipping = true
            EndPlayerTurn()
            EndPlayerTurn()
        elseif lastCard_Name == "+2"
        then--Check if the card played was a +2 card
            turnSkipping = true
            
            EndPlayerTurn()
            --Add To Our Stack Counter

            stackingCounter = stackingCounter + 2

            if UI_EnableStacking == true or UI_EnableD2Stacking == true
            then --Check if the game rules allow stacking +2 cards
               
                --[[Code For Fake Player +2 Stacking]]

                yieldState = YIELDSTATE.STACK
                coroutine.yield()
            end
<<<<<<< Updated upstream

            if playerIsStacking == false
            then
                --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
                
                DealCardsToColor(stackingCounter, currentPlayer.color)
                stackingCounter = 0
                EndPlayerTurn()
            else
                return
            end
        elseif lastCard_Desc == "WILD"
        then--Check if the card played was a wild card
            if lastCard_Name == "+4"
            then
                turnSkipping = true
            end

=======

            if playerIsStacking == false
            then
                --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
                
                DealCardsToColor(stackingCounter, currentPlayer.color)
                stackingCounter = 0
                EndPlayerTurn()
            else
                return
            end
        elseif lastCard_Desc == "WILD"
        then--Check if the card played was a wild card
            if lastCard_Name == "+4"
            then
                turnSkipping = true
            end

>>>>>>> Stashed changes
            ToggleDrawButtons(false)
            --yieldState = YIELDSTATE.WILD
            --fake a player choosing a wild card color
            WildPanelButtons(nil,nil,'WildButtonRed')
            
            EndPlayerTurn()
            
            if lastCard_Name == "+4"
            then
                --Add To Our Stack Counter
                stackingCounter = stackingCounter + 4
                
                if UI_EnableStacking == true or UI_EnableD4Stacking == true
                then
                    --Update Appropriate UI Elemtents
<<<<<<< Updated upstream
                    UI.show("StackingCardPanel")
                    UI.show("MessagePanel")
                    UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
                    UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
=======
                    UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
                    UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
                    UI.show("StackingCardPanel")
                    UI.show("MessagePanel")
>>>>>>> Stashed changes
                    ToggleDrawButtons(false)
                    
                    UI.setAttribute("StackingCardPanelText01", "Text", "Stack On Another +4 Wild Card")
                    UI.setAttribute("StackingCardPanelText02", "Text", stackingCounter)
                    --we set playerIsStacking to true and yield out of the coroutine. If the player chooses to not stack
                    --we will set playerIsStacking to false then. Otherwise when the player plays a card (which is set up to only accent another +2 at this point)
                    --it will resume the coroutine at this point, and the playerIsStacking will still be true
                    playerIsStacking = true
                    yieldState = YIELDSTATE.STACK
                    coroutine.yield()
                end
                
                if playerIsStacking == false
                then
                    --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
                    DealCardsToColor(stackingCounter, currentPlayer.color)
                    stackingCounter = 0
                    EndPlayerTurn()
                else
                    return
                end
            end
        elseif lastCard_Name == "7"
        then
            if UI_EnableSevenZero == true
            then
                
                --[[Code For Fake Player Hand Trading ]]
                --yieldState = YIELDSTATE.TRADE
                --coroutine.yield()

            end
            EndPlayerTurn()
        elseif lastCard_Name == "0"
        then
            if UI_EnableSevenZero == true
            then
                ChangeHands(currentPlayer_Index,nextPlayer_Index,#seatedPlayers)
            end
            EndPlayerTurn()
        else
            EndPlayerTurn()
        end

        yieldState = nil
    else
        if lastCard_Name == "reverse"
        then--Check if the card played was a reverse.

            clockwisePlay = not clockwisePlay
            rotationMattObject.setLock(false)

            if clockwisePlay == false then
                rotationMattObject.setRotation({0,0,0})
            end
<<<<<<< Updated upstream

            if clockwisePlay == true then
                rotationMattObject.setRotation({0,0,180})
            end

=======

            if clockwisePlay == true then
                rotationMattObject.setRotation({0,0,180})
            end

>>>>>>> Stashed changes
            if #seatedPlayers == 2
            then
                turnSkipping = true
                EndPlayerTurn()
            end
<<<<<<< Updated upstream
            rotationMattObject.setLock(true)
            EndPlayerTurn()

=======

            rotationMattObject.setLock(true)
            EndPlayerTurn()

>>>>>>> Stashed changes
        elseif lastCard_Name == "skip"
        then--Check if the card played was a skip
            turnSkipping = true
            EndPlayerTurn()
            EndPlayerTurn()
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
        elseif lastCard_Name == "+2"
        then--Check if the card played was a +2 card
            turnSkipping = true
            EndPlayerTurn()
            --Add To Our Stack Counter
            stackingCounter = stackingCounter + 2

            if UI_EnableStacking == true or UI_EnableD2Stacking == true
            then --Check if the game rules allow stacking +2 cards
            --Update Appropriate UI Elemtents
<<<<<<< Updated upstream
            UI.show("StackingCardPanel")
            UI.show("MessagePanel")
            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
            UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
=======
            --UI.show("StackingCardPanel")
            UI.show("MessagePanel")
            UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
>>>>>>> Stashed changes
            ToggleDrawButtons(false)

            UI.setAttribute("StackingCardPanelText01", "Text", "Stack On Another +2 Card")
            UI.setAttribute("StackingCardPanelText02", "Text", stackingCounter)
            --we set playerIsStacking to true and yield out of the coroutine. If the player chooses to not stack
            --we will set playerIsStacking to false then. Otherwise when the player plays a card (which is set up to only accent another +2 at this point)
            --it will resume the coroutine at this point, and the playerIsStacking will still be true
            playerIsStacking = true
            yieldState = YIELDSTATE.STACK
            coroutine.yield()
            end

            if playerIsStacking == false
            then
                --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
                DealCardsToColor(stackingCounter, currentPlayer.color)
                stackingCounter = 0
                
                EndPlayerTurn()
            else
                return
            end
        elseif lastCard_Desc == "WILD"
        then--Check if the card played was a wild card
            if lastCard_Name == "+4"
            then
                turnSkipping = true
            end

            UI.show("WildCardPanel")
            UI.show("MessagePanel")
            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Wild_Card_Message):format(currentPlayer.steam_name))
            UI.setAttribute("WildCardPanel", "visibility", currentPlayer.color)

            ToggleDrawButtons(false)

            yieldState = YIELDSTATE.WILD
            coroutine.yield()
            EndPlayerTurn()

            if lastCard_Name == "+4"
            then
                --Add To Our Stack Counter
                stackingCounter = stackingCounter + 4

                if UI_EnableStacking == true or UI_EnableD4Stacking == true
                then
                    --Update Appropriate UI Elemtents
<<<<<<< Updated upstream
                    UI.show("StackingCardPanel")
=======
                    --UI.show("StackingCardPanel")
>>>>>>> Stashed changes
                    UI.show("MessagePanel")
                    UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
                    UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
                    ToggleDrawButtons(false)

                    UI.setAttribute("StackingCardPanelText01", "Text", "Stack On Another +4 Wild Card")
                    UI.setAttribute("StackingCardPanelText02", "Text", stackingCounter)
                    --we set playerIsStacking to true and yield out of the coroutine. If the player chooses to not stack
                    --we will set playerIsStacking to false then. Otherwise when the player plays a card (which is set up to only accent another +2 at this point)
                    --it will resume the coroutine at this point, and the playerIsStacking will still be true
                    playerIsStacking = true
                    yieldState = YIELDSTATE.STACK
                    coroutine.yield()
                end

                if playerIsStacking == false
                then
                    --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
                    DealCardsToColor(stackingCounter, currentPlayer.color)
                    stackingCounter = 0
                    EndPlayerTurn()
                else
                    return
                end
            end
        elseif lastCard_Name == "7"
<<<<<<< Updated upstream
        then
            if UI_EnableSevenZero == true
            then
                UI.show("MessagePanel")
                UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Trade_Message):format(currentPlayer.steam_name) )
                UI.setAttribute("HandSwappingPanel", "visibility", currentPlayer.color)
                ToggleDrawButtons(false)
                ToggleHandTradeButtons(true)

                yieldState = YIELDSTATE.TRADE
                coroutine.yield()

                ToggleHandTradeButtons(true)
            end
            EndPlayerTurn()
        elseif lastCard_Name == "0"
        then
=======
        then
            if UI_EnableSevenZero == true
            then
                UI.show("MessagePanel")
                UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Trade_Message):format(currentPlayer.steam_name) )
                UI.setAttribute("HandSwappingPanel", "visibility", currentPlayer.color)
                ToggleDrawButtons(false)
                ToggleHandTradeButtons(true)

                yieldState = YIELDSTATE.TRADE
                coroutine.yield()

                ToggleHandTradeButtons(true)
            end
            EndPlayerTurn()
        elseif lastCard_Name == "0"
        then
>>>>>>> Stashed changes
                if UI_EnableSevenZero == true
                then
                    ChangeHands(currentPlayer_Index,nextPlayer_Index,#seatedPlayers)
                end
                EndPlayerTurn()
        else
            EndPlayerTurn()
        end
        yieldState = nil
    end
end--function GameLoop END

---------------------------------------------------------------------------------------------------------------------------
--UI RELATED FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------
--[[This function is called by the Play with Calling Uno Button toggle is changed from the Main Menu]]
function CallUnoRuleChange(n, value, ID)
    
    if value == "True"
    then
        UI_EnableCallingUno = true
    else
        UI_EnableCallingUno = false
    end
end--Function CallUnoRuleChange END
--[[This function is called when a player clicks the UNO button]]
function Player_Calling_UNO(player,b,button)
    --If uno_Called is set to true, do nothing because the button has already been pressed
    if(uno_Called)
    then
        return
    end
    uno_Called = true
    HideUNO()
    if player.color ~= color_Has_Uno
    then
        --If a player calls uno on someone else, we announce it to the table
        broadcastToAll( string.format("%s Called Uno On %s! %s Must Draw 2 Cards!",player.color,color_Has_Uno,color_Has_Uno), getColorValueFromPlayer(color_Has_Uno))
        --If a player clicks the UNO button that is not the one with UNO, we penalize them by giving them 2 cards
        DealCardsToColor(2,color_Has_Uno)
    else
        --We also broadcast that a player has UNO so that players are aware
        broadcastToAll( ("%s has UNO!"):format(player.color) ,player.color)
    end
    uno_Called = false
end--Function Player_Calling_UNO END
--[[This function is called by the 'Draw UNO Penalty Button' for use when playing without the 'Call Uno Button']]
function Draw_UNO_Penalty(player,b,button)
    DealCardsToColor(2,player.color)
    removeColorFromUNOTable(player.color)
    UI.setAttribute("UNO_Penalty_Button","visibility",getVisibilityTargerts(colorsWithUNO))
    if(#colorsWithUNO < 1)
    then
        UI.setAttribute("UNO_Penalty_Button","active","false")
    end
end--Function Draw_UNO_Penalty END
--[[This function is called when the "Don't Stack" button is click from the stacking card UI panel]]
function StackingPanelButtons()

    playerIsStacking = false
    coroutine.resume(gameloopCoroutine)

    UI.hide("StackingCardPanel")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function StackingPanelButtons END
--[[This function is called by the buttons from the Wild Card UI panel]]
function WildPanelButtons(a,b, ID)
    if ID == "WildButtonRed"
    then
        lastCard_Desc = "RED"
    elseif ID == "WildButtonBlue"
    then
        lastCard_Desc = "BLUE"
    elseif ID == "WildButtonYellow"
    then
        lastCard_Desc = "YELLOW"
    elseif ID == "WildButtonGreen"
    then
        lastCard_Desc = "GREEN"
    end

    broadcastToAll("The Color Is Now ".. lastCard_Desc, getColorValueFromCard(lastCard_Desc))
    playMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    rotationMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    coroutine.resume(gameloopCoroutine)

    UI.hide("WildCardPanel")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function WildPanelButtons END
--[[This function is called by the buttons from the Trade Hands UI panel]]
function HandTradeButtons(a,b,ID)

    other_Player = nil

    if ID == "Player_White"
    then
        print(a.steam_name .. " wants to trade hands with White")
        other_Player=Player.White
    elseif ID == "Player_Red"
    then
        print(a.steam_name .. " wants to trade hands with Red")
        other_Player=Player.Red
    elseif ID == "Player_Orange"
    then
        print(a.steam_name .. " wants to trade hands with Orange")
        other_Player=Player.Orange
    elseif ID == "Player_Yellow"
    then
        print(a.steam_name .. " wants to trade hands with Yellow")
        other_Player=Player.Yellow
    elseif ID == "Player_Green"
    then
        print(a.steam_name .. " wants to trade hands with Green")
        other_Player=Player.Green
    elseif ID == "Player_Blue"
    then
        print(a.steam_name .. " wants to trade hands with Blue")
        other_Player=Player.Blue
    elseif ID == "Player_Purple"
    then
        print(a.steam_name .. " wants to trade hands with Purple")
        other_Player=Player.Purple
    elseif ID == "Player_Pink"
    then
        print(a.steam_name .. " wants to trade hands with Pink")
        other_Player=Player.Pink
    elseif ID == "No_Trade"
    then
        print(a.steam_name .. " Doesn't Want To Trade Hands")
    end

    if other_Player != nil
    then
        ChangeHands(getIndexFromPlayer(a.color),getIndexFromPlayer(other_Player.color),0)
        broadcastToAll("" .. a.color .. " is trading their hand with " .. other_Player.color,{1,1,1} )
    end



    coroutine.resume(gameloopCoroutine)

    UI.setAttribute("HandSwappingPanel", "Active", "false")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function HandTradeButtons END
--[[This function is used to show or hide the hand trading buttons]]
function ToggleHandTradeButtons(value)

    if value == true
    then
        UI.setAttribute("HandSwappingPanel", "active", "true")
        for i, _player in ipairs(PLAYERS_REF)
        do

            if _player == Player.White
            then
                if _player.seated == true or isFakePlayer(_player.color)
                then
                    UI.setAttribute("Player_White", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_White", "Text", "Fake White")
                    else
                        UI.setAttribute("Player_White", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_White", "Interactable", "false")
                        UI.setAttribute("Player_White", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_White", "Interactable", "false")
                    UI.setAttribute("Player_White", "Text", "Not Seated")
                end
            elseif _player == Player.Red
            then
                if _player.seated == true or isFakePlayer(_player.color)
                then
                    UI.setAttribute("Player_Red", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_Red", "Text", "Fake Red")
                    else
                        UI.setAttribute("Player_Red", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Red", "Interactable", "false")
                        UI.setAttribute("Player_Red", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Red", "Interactable", "false")
                    UI.setAttribute("Player_Red", "Text", "Not Seated")
                end
            elseif _player == Player.Orange
            then
                if _player.seated == true or isFakePlayer(_player.color)
                then
                    UI.setAttribute("Player_Orange", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_Orange", "Text", "Fake Orange")
                    else
                        UI.setAttribute("Player_Orange", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Orange", "Interactable", "false")
                        UI.setAttribute("Player_Orange", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Orange", "Interactable", "false")
                    UI.setAttribute("Player_Orange", "Text", "Not Seated")
                end
            elseif _player == Player.Yellow
            then
                if _player.seated == true or isFakePlayer(_player.color)
                then
                    UI.setAttribute("Player_Yellow", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_Yellow", "Text", "Fake Yellow")
                    else
                        UI.setAttribute("Player_Yellow", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Yellow", "Interactable", "false")
                        UI.setAttribute("Player_Yellow", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Yellow", "Interactable", "false")
                    UI.setAttribute("Player_Yellow", "Text", "Not Seated")
                end
            elseif _player == Player.Green
            then
                if _player.seated == true or isFakePlayer(_player.color)
                then
                    UI.setAttribute("Player_Green", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_Green", "Text", "Fake Green")
                    else
                        UI.setAttribute("Player_Green", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Green", "Interactable", "false")
                        UI.setAttribute("Player_Green", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Green", "Interactable", "false")
                    UI.setAttribute("Player_Green", "Text", "Not Seated")
                end
            elseif _player == Player.Blue
            then
                if _player.seated == true or isFakePlayer(_player.color)
                then
                    UI.setAttribute("Player_Blue", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_Blue", "Text", "Fake Blue")
                    else
                        UI.setAttribute("Player_Blue", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Blue", "Interactable", "false")
                        UI.setAttribute("Player_Blue", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Blue", "Interactable", "false")
                    UI.setAttribute("Player_Blue", "Text", "Not Seated")
                end
            elseif _player == Player.Purple
            then
                if _player.seated == true or isFakePlayer(_player.color)
                then
                    UI.setAttribute("Player_Purple", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_Purple", "Text", "Fake Purple")
                    else
                        UI.setAttribute("Player_Purple", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Purple", "Interactable", "false")
                        UI.setAttribute("Player_Purple", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Purple", "Interactable", "false")
                    UI.setAttribute("Player_Purple", "Text", "Not Seated")
                end
            elseif _player == Player.Pink
            then
                if _player.seated == true or isFakePlayer(_player)
                then
                    UI.setAttribute("Player_Pink", "Interactable", "true")
                    if isFakePlayer(_player.color)
                    then
                        UI.setAttribute("Player_Pink", "Text", "Fake Pink")
                    else
                        UI.setAttribute("Player_Pink", "Text", _player.steam_name)
                    end
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Pink", "Interactable", "false")
                        UI.setAttribute("Player_Pink", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Pink", "Interactable", "false")
                    UI.setAttribute("Player_Pink", "Text", "Not Seated")
                end
            end

        end
    elseif value == false
    then
        UI.setAttribute("HandSwappingPanel", "active", "false")
    end

end--Function ToggleHandTradeButtons END
--[[This function is used to show or hide the draw card buttons]]
function ToggleDrawButtons(value)
    if value == false
    then
        drawButtons[0].setScale({0,0,0})
        drawButtons[1].setScale({0,0,0})
    else
        drawButtons[0].setScale({0.5,0.5,0.5})
        drawButtons[1].setScale({0.5,0.5,0.5})
    end
end--Function ToggleDrawButtons END
--[[This function is called by the Hide/Show menu button and should be self explanatory]]
function ToggleStartMenu(value)

    if UI.getAttribute("StartGameMenu", "active") == "true"
    then
        UI.setAttribute("StartGameMenu", "active", "false")
        UI.setAttribute("MainMenuContainer", "color", "RGBA(0.105,0.157,0.22,0)")
        UI.setAttribute("MainMenuContainer", "height", "5%")
        UI.setAttribute("MainMenuContainer", "width", "15%")
        UI.setAttribute("HideMenuButton", "text", "Show Main Menu")
        UI.setAttribute("HideMenuButton", "height", "100%")

    else
        UI.setAttribute("StartGameMenu", "active", "true")
        UI.setAttribute("MainMenuContainer", "color", "RGBA(0.105,0.157,0.22,1)")
        UI.setAttribute("MainMenuContainer", "height", "90%")
        UI.setAttribute("MainMenuContainer", "width", "50%")
        UI.setAttribute("HideMenuButton", "text", "Hide Main Menu")
        UI.setAttribute("HideMenuButton", "height", "5%")
    end

end--Function ToggleStartMenu END
--[[This function is called by the Draw Deck Rule Toggle Butttons from the Main Menu]]
function CardDrawingRuleChange(n, value, id)

    if value == "True"
    then
        if id == "drawOneCard"
        then
            UI_DrawOneCard = true
            UI.setAttribute("TurnPassingRuleRow", "active", "False")
        elseif id == "drawManyCards"
        then
            UI_DrawOneCard = false
            UI.setAttribute("TurnPassingRuleRow", "active", "True")
        end
    end

end--Function CardDrawingRuleChange
--[[This function is called by the "Allow Turn Passing" buttons from the Main Menu]]
function TurnPassingRuleChange(n, value, id)

    if value == "True"
    then
        if id == "allowPassing"
        then
            UI_AllowTurnPassing = true
        elseif id == "noPassing"
        then
            UI_AllowTurnPassing = false
        end
    end

end--Function CardDrawingRuleChange
--[[This function is called by the Stacking Rule Toggle Buttons from the Main Menu]]
function StackingRuleChange(n , value, id)

    if value == "True"
    then--First we check if value is true, meaning we are only listening to the buttons that have been toggled on
        if id == "noStackToggle"
        then--If 'Dont Stack Cards' has been chosen
            UI_EnableStacking = false
            UI_EnableD2Stacking = false
            UI_EnableD4Stacking = false
        elseif id == "allStackToggle"
        then--If 'Stack +2 and +4 Cards' has been chosen
            UI_EnableStacking = true
            UI_EnableD2Stacking = false
            UI_EnableD4Stacking = false
        elseif id == "p2StackToggle"
        then--If 'Only Stack +2 Cards' has been chosen
            UI_EnableStacking = false
            UI_EnableD2Stacking = true
            UI_EnableD4Stacking = false
        elseif id == "p4StackToggle"
        then--if 'Only Stack +4 Cards' has been chosen
            UI_EnableStacking = false
            UI_EnableD2Stacking = false
            UI_EnableD4Stacking = true
        end
    end

end--Function StackingRuleChange END
--[[This function is called by the 7-0 Rule Toggle Button from the Main Menu]]
function SevenZeroRuleChange(n, value, id)

    if value == "True"
    then
       UI_EnableSevenZero = true
    else
        UI_EnableSevenZero = false
    end
end--Function SevenZeroRuleChange END
--[[This function is called by the "Pick Player One" element from the Main Menu, and is used to pick the first player in order]]
function PickPlayerOne(obj,color)

    if color ~= "Black"
    then
        if playerOne_Index + 1 > #seatedPlayers
        then
            playerOne_Index = 1
        else
            playerOne_Index = playerOne_Index + 1
        end
        UI.setAttribute("playerOneButton", "text", seatedPlayers[playerOne_Index].steam_name )
        UI.setAttribute("playerOneButton", "color", seatedPlayers[playerOne_Index].color)
    end

end--Function PickPlayerOne END

---------------------------------------------------------------------------------------------------------------------------
--HELPER FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

function getVisibilityTargerts()
    tempString = "|"
    for i=1, #colorsWithUNO
    do
        tempString = tempString .. colorsWithUNO[i] .. "|"
    end
    return tempString

end

function removeColorFromUNOTable(color)
    for i=1,#colorsWithUNO
    do
        if colorsWithUNO[i] == color
        then
            table.remove( colorsWithUNO, i )
        end
    end
end

function isFakePlayer(player_color)
    for i, _fakePlayer in ipairs(FAKEPLAYERS)
    do
        if _fakePlayer.color == player_color
        then
            return true
        end
    end
    return false
end

function doFakePlayerTurn(player_color,cardDrawn)


    local cardPlayed = false
    for i=1,#Player[player_color].getHandObjects()
    do        
        if Player[player_color].getHandObjects()[i].getName() == lastCard_Name or Player[player_color].getHandObjects()[i].getDescription() == lastCard_Desc or Player[player_color].getHandObjects()[i].getDescription() == 'WILD'
        then
            Player[player_color].getHandObjects()[i].setVar("FakePlayerCard",true)
            local FixedPos = playDeckZone.getPosition()
            Player[player_color].getHandObjects()[i].setPosition({FixedPos.x,3,FixedPos.z}, false, true)
            cardPlayed = true
            break
        end     
    end
    if cardPlayed == false
    then
        if UI_DrawOneCard == false or cardDrawn == false
        then
            DealCardsToColor(1,player_color)
            doFakePlayerTurn(player_color,true)
        else
            EndPlayerTurn()
        end
    else

    end
end

function getNextSeatedPlayerIndex(currentIndex)
    local newIndex = currentIndex + 1
    if newIndex > #seatedPlayers
    then
        newIndex = 1
    end
    return newIndex
end

--[[Helper Function to return the index a player color is in the 'seatedPlayers' table that keeps track of currently seated players]]
function getIndexFromPlayer(player_color)
    for i=1,#seatedPlayers
    do
        if seatedPlayers[i].color == player_color
        then
            return i
        end
    end
end--Function getIndexFromPlayer END
--[[Helper Function to return a color code give a PLAYERS_REF color string]]
function getColorValueFromPlayer (player_color)
    if player_color == "Green"
    then
        return {0.129,0.701,0.168}

    elseif player_color == "Blue"
    then
        return {0.118, 0.53, 1}

    elseif player_color == "Purple"
    then
        return {0.627, 0.125, 0.941}

    elseif player_color == "Pink"
    then
        return {0.96, 0.439, 0.807}

    elseif player_color == "White"
    then
        return {1, 1, 1}

    elseif player_color == "Red"
    then
        return {0.856, 0.1, 0.094}

    elseif player_color == "Orange"
    then
        return {0.956, 0.392, 0.113}

    elseif player_color == "Yellow"
    then
        return {0.905, 0.898, 0.172}

    elseif player_color == "Grey"
    then
        return {0.5, 0.5, 0.5}

    elseif player_color == "Black"
    then
        return {0.25, 0.25, 0.25}

    end

end--Function getColorValueFromPlayer END
--[[Helper Function to return a color code given a card color string]]
function getColorValueFromCard (card_color)

    if card_color == "GREEN"
    then
        return {0.129,0.701,0.168}
    end

    if card_color == "BLUE"
    then
        return {0.118, 0.53, 1}
    end

    if card_color == "RED"
    then
        return {0.856, 0.1, 0.094}
    end

    if card_color == "YELLOW"
    then
        return {0.905, 0.898, 0.172}
    end

end--Function getColorValueFromCard END
--[[Helper Function to return the apropriate TOKENPOSITION vector given a PLAYERS_REF color string]]
function getTokenLocation(color)

    if color == "Green"
    then
        return TOKENLOCATIONS_REF.GREEN
    elseif color == "Blue"
    then
        return TOKENLOCATIONS_REF.BLUE
    elseif color == "Purple"
    then
        return TOKENLOCATIONS_REF.PURPLE
    elseif color == "Pink"
    then
        return TOKENLOCATIONS_REF.PINK
    elseif color == "White"
    then
        return TOKENLOCATIONS_REF.WHITE
    elseif color == "Red"
    then
        return TOKENLOCATIONS_REF.RED
    elseif color == "Orange"
    then
        return TOKENLOCATIONS_REF.ORANGE
    elseif color == "Yellow"
    then
        return TOKENLOCATIONS_REF.YELLOW
    elseif color == "Black"
    then
        return TOKENLOCATIONS_REF.WHITE
    end

end--Function getTokenLocation END
--[[Helper Function to return the appropriate TOKENROATIONS vector given a PLAYERS_REF color string]]
function getTokenRotation(color)
    if color == "Green"
    then
        return TOKENROTATIONS_REF.GREEN
    elseif color == "Blue"
    then
        return TOKENROTATIONS_REF.BLUE
    elseif color == "Purple"
    then
        return TOKENROTATIONS_REF.PURPLE
    elseif color == "Pink"
    then
        return TOKENROTATIONS_REF.PINK
    elseif color == "White"
    then
        return TOKENROTATIONS_REF.WHITE
    elseif color == "Red"
    then
        return TOKENROTATIONS_REF.RED
    elseif color == "Orange"
    then
        return TOKENROTATIONS_REF.ORANGE
    elseif color == "Yellow"
    then
        return TOKENROTATIONS_REF.YELLOW
    elseif color == "Black"
    then
        return TOKENROTATIONS_REF.WHITE
    end

end--Function getTokenRotation END
--[[Helper Function to clamp the value between the min value and the max value]]
function ClampValue(value,min,max)
    if value < min
    then
        value = min
    end

    if value > max
    then
        value = max
    end

    return value
end--Function ClampValue END
--[[Debug function to print the arguments passed from the caller. Helpful to findout what information is passed from object events or callback functions]]
function DebugFunction(a, b, c, d, e)
    print("Debug Print: ", a , " | ", b ," | ", c, " | ", d, " | ", e)
end--Function DebugFunction END